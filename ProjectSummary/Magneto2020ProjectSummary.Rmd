---
title: "Magneto Summer2020 Summary"
author: Benjamin Ott
date: 
output: pdf_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("knitr")
```

## DigitizationTODO.py 

The need for a program that told us what images had been digitized by previous versions became apparent, as it wouldn't be possible to re-digitize all of the images when the program was stopped.  This was easiest to run in python because of its efficient computing capability.  It asks the user for two .txt files *Figure: DigTODO1*; These files contain the path of one item, in our case these were the paths of the origional image and the path of the digitized image.



***

**Original Image Path**

/home/ben/magneto/Images/AGC-D-19010530-19040829/AGC-D-19031103-19031105.tif

**Digitized Image Path**

/home/ben/magneto/Digitized_Data/Algorithm2/AGC-D-19031103-19031105.tif.csv

***

The path was needed so that the digitize function would be able to find the image that hasn't been digitized yet (see TISForAutomation for more details about digitization function).  

  The path was then split into the name, the path and the file type;  This program was designed to take any file type (.tiff, .tif, .tif.csv, .tif.png) as it separates by both "." and "/" to obtain

***

File Path: */home/ben/magneto/Images/AGC-D-19010530-19040829/*

File Name: *AGC-D-19031103-19031105*

File Type: *.tif*

***

This aloud us to only compare the file names of images and digitized images, without needing to worry about the path or the file type.  This caused an decrease of the computation time as there wasn't any splitting done when the comparison was happening.  This caused another problem, as we were only comparing the names, in some cases there was digitized images that don't have original images;  code was created to identify when this happens and print it to screen for the user to see.  We recorded these in a document **DigitizedNonImages.txt** to hopefully identify the original images one day.



As the comparisons happen in the function, They are recorded and outputed to a .csv file that gets saved locally. Example of the output *Figure: DigTODO2*.  In order of the columns, it saves:  **Image Path, Image Name, If the image has been digitized, Digitized Path, Digitized Name**.  Along with this .csv, there is also information that is printed to the user about the data *Figure: DigTODO3*;  This includes information to ensure that all of the files are accounted for in the final document, along with the number of digitized images and the number of images that still need to be digitized.


```{r, out.width = '95%', echo = FALSE, fig.cap="DigTODO1: The user input"}
knitr::include_graphics("~/Magneto2020/ProjectSummary/ImagesForSummary/digTODOUserInput.png")
```

```{r, out.width = '95%', echo = FALSE, fig.cap="DigTODO2: .csv Output File Example"}
knitr::include_graphics("~/Magneto2020/ProjectSummary/ImagesForSummary/DigOutputcsv.png")
```

```{r, out.width = '95%', echo = FALSE, fig.cap="DigTODO3: Extra Information for User"}
knitr::include_graphics("~/Magneto2020/ProjectSummary/ImagesForSummary/DigUsrOutput.png")
```




## Finding Specific Days

To aid with the automation of TIS, a function was created to find all of the files we have that contain the specified **keyword**, which could be a day, a year, or any specific keyword that one would want to search for.  This function is aptly named getImagesForDate which uses the fs package. Part of the fs package is the ability to use commands like grep from bash to search.  It can be narrowed to a specific directory, or it can search recursively throughout all of the files from your home directory.

One problem that was created when making this function was the handling of un-foreseeable errors two, are great examples of this.

### Using Grep with Symlinks

Symbolic links, or Symlinks, are pointers to another directory on another system for example.  This became prevalent when using the magneto directory on the Trent server; I had access to it, but because it is a Symlink, to search that directory we had to first find all of the pointers/Symlinks then look recursively into all of those specific directory's separately.

### Exeption handeling

Even with the symlinks working, there was still a problem with the chance of a directory being un-accessable by that specific user.  This problem came when looking through the symlink directory for magneto *Figure: FindingDays1*.  As this directory was a hidden directory that no one has access to, the handling had to be completed in such a way that the program would still complete, and just print a warning to the screen notifying the user that there was such a directory in the search radius.


This keyword searcher was implemented into the **AutomationScript**; It allows users to digitize only specific images or specific ranges of images based off of the **DigitizationTODO** csv.  The user only needs to know the keyword and the function will find anything in the specified or non specified searching radius.


```{r, out.width = '95%', echo = FALSE, fig.cap="FindingDays1: Permission Denied"}
knitr::include_graphics("~/Magneto2020/ProjectSummary/ImagesForSummary/permissionDeniedErrorGetimages.png")
```

## Finding Image Gaps

The long term goal for the magneto project is to obtain a continuous time series of all the data, in order to ensure that we had all of the images for each day a python program was written. 

The first thing that needed to happen was to split the names from our file system.  Using part of the algorithm created for the DigitizationTODO function, we were able to split the names into key parts; For example, AGC-D-19031103-19031105.tif, was split into these key parts:

***

The Observatory: *AGC*

The Axis of the plot: *D*

Start Date: *19031103*

End Date: *19031105*

***

Using the imported datetime package, the Start Date and End Date were successfully changed into a datetime object which we used later to produce the gaps.  Any dates that weren't able to be converted were then sent to the user at the end of the script.  An example of this was an image that was dated 18650228-18650229; The program successfully returned an error, and was verified with a calendar from 1865 that there us no date February 29th in that year.

Arranging the successful conversions into an array consisting of columns for each of the cases,  AGC-D, AGC-H, AGC-V, AGC-D V and H, TOR-D, TOR-H, TOR-V, and TOR-D V and H; Storing a tuple of (Start Date, End Date).  It was then possible to rearrange the items in the column by their start date. 

A problem arose here, as we needed to keep the start and end date of the directory the original image came from.  This was not easy as some of the directories contained more then one Axis from a specific day, therefore this directory start and end date had to be added to any columns that were appended by the images in that directory. 

Now starting at the first element in a row, each End Date was compared to the next Start Date.  The advantage of using the datetime import is, subtracting two datetime objects gives the difference in days between them, which is the gap of the images we don't currently have.  This data is being sent to NRCAN to obtain these missing images so we can start the work on making the continuous time series in the future.


## Brightness Testing

A future goal put up by Mark Weygang in his masters thesis was to determine a way of automating the brightness part of TIS.  Currently the user would have to manually set if an image we were digitizing was bright **Figure: Bright1** or could be considered to be okay/not bright **Figure: Bright2**

```{r, out.width = '95%', echo = FALSE, fig.cap="Bright1: Considered to be bright"}
knitr::include_graphics("~/Magneto2020/ProjectSummary/ImagesForSummary/brightImage.png")
```

```{r, out.width = '95%', echo = FALSE, fig.cap="Bright2: Considered to be a good contrast"}
knitr::include_graphics("~/Magneto2020/ProjectSummary/ImagesForSummary/goodContrast.png")
```
