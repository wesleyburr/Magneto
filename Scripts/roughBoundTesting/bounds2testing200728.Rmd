---
title: "find-bounds2Testing.Rmd"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
ImageTesting <- read.csv("~/Magneto2020/DataCSV/TODOBatch5.csv", header = TRUE, stringsAsFactors = FALSE)
```
```{r}
i <- 1

```

```{r}
library(magneto)
file_loc <- as.character(ImageTesting[i,1])
imageName <- as.character(ImageTesting[i,2])

imageRAW <- tiff_import(fileName = imageName, fileLoc = file_loc)
image <- .horizontal_image_check(imageRAW)
imagecut <- .trim_top_bottom(image)
imageSides <- .get_trace_start_ends(imagecut, returnMat = FALSE)
imageProcessed <- .processImage(imagecut, cutoffQuantile = 0.95)
imageMatrix <- imageProcessed$gaussImageMatrix[,-c(0:imageSides$Start,imageSides$End:ncol(imageProcessed$gaussImageMatrix))]
topcut <- .top_image_cut(imageMatrix = imageMatrix)
imageMatrixTopCut <- imageMatrix[-c(0:topcut),]

```



```{r}
library("zoo")
vert <- t(imageMatrixTopCut)
rolledImage <- t(rollmean(vert, k = 75, fill = "extend"))
rolledImage[which(rolledImage != 0)] <- 1
```


```{r Getting UpperBound For RolledImage}
max_roc <- 20
while (TRUE) {
min_white <- apply(rolledImage, MARGIN = 2, FUN = function(x) {
   if (sum(x) == 0) {
     white <- 0
   } 
   else {
   white <- min( which(x == 1) )
   }
  return(white)
  })
  
  # Some are text and artifacts
  d_e <- diff(min_white)
  bad_text <- which(abs(d_e) >= max_roc)  # need to check here
  if (is.na(bad_text[1]) == FALSE) {
    # Instead, jump to other side of these ... then find the first white going down
    min_white_fix <- apply(rolledImage[, bad_text], MARGIN = 2, FUN = function(x) {
      first_white <- min( which(x == 1) )
      bottom_first <- min( which(x[(first_white + 1):length(x)] == 0) )
      tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
      if (tempMin > (mean(min_white) + 50)) {
        bottom_first <- min( which(x[(tempMin + 1):length(x)] == 0) )
        tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
        return(tempMin)
      }
      else {
        return(tempMin)
      }
    })
    
    min_white[bad_text] <- min_white_fix
    
  }
}
  correctedWhite <- ncol(rolledImage) - min_white
```


#' Finding Rough Bounds for Two Traces
#'
#' @param imageMatrix An imported image, can be imported with tiff_import()
#' @param FindPeaksdf -- Row Index, Max Height, PeakStart, PeakEnd -- identifies traces by summing rows
#' @param rowSums Of the imported matrix from original picture
#' @param max_roc Maximum Rate-of-Change of pixel location column-by-column
#' @returns
#
```{r}
  max_roc <- 20

  rowsums <- rowSums(imageMatrix)
  
 min_white <- apply(imageMatrix, MARGIN = 2, FUN = function(x) {
   if (sum(x) == 0) {
     white <- 0
   } 
   else {
   white <- min( which(x == 1) )
   }
  return(white)
  })
  
  # Some are text and artifacts
  d_e <- diff(min_white)
  bad_text <- which(abs(d_e) >= max_roc)  # need to check here
  if (is.na(bad_text[1]) == FALSE) {
    # Instead, jump to other side of these ... then find the first white going down
    min_white_fix <- apply(imageMatrix[, bad_text], MARGIN = 2, FUN = function(x) {
      first_white <- min( which(x == 1) )
      bottom_first <- min( which(x[(first_white + 1):length(x)] == 0) )
      tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
      if (tempMin > (mean(min_white) + 50)) {
        bottom_first <- min( which(x[(tempMin + 1):length(x)] == 0) )
        tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
        return(tempMin)
      }
      else {
        return(tempMin)
      }
    })
    
    min_white[bad_text] <- min_white_fix
    
  }
  correctedWhite <- ncol(imageMatrix) - min_white
  ############################################################################
  ##
  ## Lower bound, trace 4? (lower = bottom of image)

  # Last white pixel per column
  max_white <- apply(imageMatrix, MARGIN = 2, FUN = function(x) {
    max( which(x == 1) )
  })

  # Some are text and artifacts
  d_e <- diff(max_white)
  bad_text <- which(abs(d_e) >= max_roc)  # need to check bad_text for length > 1

  # Instead, jump to other side of these ... then find the first white going down
  max_white_fix <- apply(imageMatrix[, bad_text], MARGIN = 2, FUN = function(x) {
    last_white <- max( which(x == 1) )
    bottom_black <- max( which(x[1:(last_white - 1)] == 0) )
    max( which( x[1:(bottom_black - 1)] == 1 ) )
  })
  max_white[bad_text] <- max_white_fix

  # fix the bound indexes to make sense?
  #return(list(top_bound = min_white, bottom_bound = max_white))


```


```{r}
i <- i + 1
```

