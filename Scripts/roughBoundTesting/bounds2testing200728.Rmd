---
title: "find-bounds2Testing.Rmd"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
ImageTesting <- read.csv("~/Magneto2020/DataCSV/TODOBatch5.csv", header = TRUE, stringsAsFactors = FALSE)
```
```{r}
i <- 1

```

```{r}
i <- 1
library(magneto)
file_locGood <- as.character(ImageTesting[i,1])
imageNameGood <- as.character(ImageTesting[i,2])

imageRAWGood <- tiff_import(fileName = imageNameGood, fileLoc = file_locGood)
imageGood <- .horizontal_image_check(imageRAWGood)
imagecutGood <- .trim_top_bottom(imageGood)
imageSidesGood <- .get_trace_start_ends(imagecutGood, returnMat = FALSE)
imageProcessedGood <- .processImage(imagecutGood, cutoffQuantile = 0.95)
imageMatrixGood <- imageProcessedGood$gaussImageMatrix[,-c(0:imageSidesGood$Start,imageSidesGood$End:ncol(imageProcessedGood$gaussImageMatrix))]
topcutGood <- .top_image_cut(imageMatrix = imageMatrixGood, percentFromEdge = 2, percentEdgeForLeft = 25)
bottomcutGood <- .bottom_image_cut(imageMatrix = imageMatrixGood, percentEdgeForLeft = 25, percentFromEdge = 2, shortestAlowedSeqOfZeros = 25)
imageMatrixTopCutGood <- imageMatrixGood[-c(0:topcutGood),]
rowsumsImageGood <- rowSums(imageMatrixGood)
```

```{r}
i <- 147
library(magneto)
file_locBad <- as.character(ImageTesting[i,1])
imageNameBad <- as.character(ImageTesting[i,2])

imageRAWBad <- tiff_import(fileName = imageNameBad, fileLoc = file_locBad)
imageBad <- .horizontal_image_check(imageRAWBad)
imagecutBad <- .trim_top_bottom(imageBad)
imageSidesBad <- .get_trace_start_ends(imagecutBad, returnMat = FALSE)
imageProcessedBad <- .processImage(imagecutBad, cutoffQuantile = 0.95)
imageMatrixBad <- imageProcessedBad$gaussImageMatrix[,-c(0:imageSidesBad$Start,imageSidesBad$End:ncol(imageProcessedBad$gaussImageMatrix))]
topcutBad <- .top_image_cut(imageMatrix = imageMatrixBad, percentFromEdge = 2, percentEdgeForLeft = 25)
bottomcutBad <- .bottom_image_cut(imageMatrix = imageMatrixBad, percentEdgeForLeft = 25, percentFromEdge = 2, shortestAlowedSeqOfZeros = 25)
imageMatrixTopCutBad <- imageMatrixBad[-c(0:topcutBad),]
rowsumsImageBad <- rowSums(imageMatrixBad)
```

```{r}
library("zoo")
vert <- t(imageMatrixTopCut)
rolledImage <- t(rollmean(vert, k = 75, fill = "extend"))
rolledImage[which(rolledImage != 0)] <- 1
```


```{r Getting UpperBound For RolledImage}
max_roc <- 20
#while (TRUE) {
min_white <- apply(rolledImage, MARGIN = 2, FUN = function(x) {
   if (sum(x) == 0) {
     white <- 0
   } 
   else {
   white <- min( which(x == 1) )
   }
  return(white)
  })
  
  # Some are text and artifacts
d_e <- diff(min_white)
bad_text <- which(abs(d_e) >= max_roc)  # need to check here
if (is.na(bad_text[1]) == FALSE) {
  # Instead, jump to other side of these ... then find the first white going down
  min_white_fix <- apply(rolledImage[, bad_text], MARGIN = 2, FUN = function(x) {
    ones <- which(x == 1)
    if (length(ones) != 0) { # there is a one in that row
      first_white <- min( ones )
      bottom_first <- min( which(x[(first_white + 1):length(x)] == 0) )
      tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
      if (tempMin > (mean(min_white) + 50)) {
        bottom_first <- min( which(x[(tempMin + 1):length(x)] == 0) )
        tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
        return(tempMin)
      }
      else {
        return(tempMin)
      }
    }
    else {
      
    }
  })
  
  min_white[bad_text] <- min_white_fix
  
}
#}
  correctedWhite <- ncol(rolledImage) - min_white
```


#' Finding Rough Bounds for Two Traces
#'
#' @param imageMatrix An imported image, can be imported with tiff_import()
#' @param FindPeaksdf -- Row Index, Max Height, PeakStart, PeakEnd -- identifies traces by summing rows
#' @param rowSums Of the imported matrix from original picture
#' @param max_roc Maximum Rate-of-Change of pixel location column-by-column
#' @returns
#
```{r}
  max_roc <- 20

  rowsums <- rowSums(imageMatrix)
  
 min_white <- apply(imageMatrix, MARGIN = 2, FUN = function(x) {
   if (sum(x) == 0) {
     white <- 0
   } 
   else {
   white <- min( which(x == 1) )
   }
  return(white)
  })
  
  # Some are text and artifacts
  d_e <- diff(min_white)
  bad_text <- which(abs(d_e) >= max_roc)  # need to check here
  if (is.na(bad_text[1]) == FALSE) {
    # Instead, jump to other side of these ... then find the first white going down
    min_white_fix <- apply(imageMatrix[, bad_text], MARGIN = 2, FUN = function(x) {
      first_white <- min( which(x == 1) )
      bottom_first <- min( which(x[(first_white + 1):length(x)] == 0) )
      tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
      if (tempMin > (mean(min_white) + 50)) {
        bottom_first <- min( which(x[(tempMin + 1):length(x)] == 0) )
        tempMin <- min( which( x[(bottom_first + 1):length(x)] == 1 ) )
        return(tempMin)
      }
      else {
        return(tempMin)
      }
    })
    
    min_white[bad_text] <- min_white_fix
    
  }
  correctedWhite <- ncol(imageMatrix) - min_white
  ############################################################################
  ##
  ## Lower bound, trace 4? (lower = bottom of image)

  # Last white pixel per column
  max_white <- apply(imageMatrix, MARGIN = 2, FUN = function(x) {
    max( which(x == 1) )
  })

  # Some are text and artifacts
  d_e <- diff(max_white)
  bad_text <- which(abs(d_e) >= max_roc)  # need to check bad_text for length > 1

  # Instead, jump to other side of these ... then find the first white going down
  max_white_fix <- apply(imageMatrix[, bad_text], MARGIN = 2, FUN = function(x) {
    last_white <- max( which(x == 1) )
    bottom_black <- max( which(x[1:(last_white - 1)] == 0) )
    max( which( x[1:(bottom_black - 1)] == 1 ) )
  })
  max_white[bad_text] <- max_white_fix

  # fix the bound indexes to make sense?
  #return(list(top_bound = min_white, bottom_bound = max_white))


```


```{r}
i <- i + 1
```


