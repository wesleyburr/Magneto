---
title: "testingEnv"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
ImageTesting <- read.csv("~/Magneto2020/DataCSV/TODOBatch5.csv", header = TRUE, stringsAsFactors = FALSE)
```
```{r}
k <- 4
j <- sample(1:26000, size = 100, replace = FALSE)

```


```{r}
#for k in 1:100)
i <- j[k]
#i <- 1
#library(magneto)
#library("zoo")
  file_loc <- as.character(ImageTesting[i,1])
  imageName <- as.character(ImageTesting[i,2])

  imageRAW <- tiff_import(fileName = imageName, fileLoc = file_loc)
  image <- magneto::.horizontal_image_check(imageRAW)
  imagecut <- magneto::.trim_top_bottom(image, trimAmountTop = 100, trimAmountBottom = 50) #takes off the usual flair spots
  #imageSides <- magneto::.get_trace_start_ends(imagecut, returnMat = FALSE)
  imageSides <- magneto::.get_trace_start_ends(imagecut, returnMat = FALSE, cutPercentage = 2) # two vertical lines
  imageMatrix <- .process_image(imagecut) # checks bright and processes returns processed
  #imageMatrix <- edge_detection(imagecut, method = "Sobel")
  imageWithoutSides <- imageMatrix[, -c(0:imageSides$Start, imageSides$End:ncol(imageMatrix))] #takes away the sides found above
  # finds top horizontal line
  topcut <- magneto::.top_image_cut(imageMatrix = imageWithoutSides, percentFromEdge = 2, percentEdgeForLeft = 25)
  #finds bottom horizontal line
  bottomcut <- tryCatch(magneto::.bottom_image_cut(imageMatrix = imageWithoutSides, percentEdgeForLeft = 25,
                                                   percentFromEdge = 2, shortestAlowedSeqOfZeros = 15), warning = function(w) w)
  if (inherits(bottomcut, "warning")) {
    print(bottomcut)
    print(imageName)
    bottomcut <- nrow(imageMatrix) # this is the only way I know of doing this
  }
  if (bottomcut != nrow(imageMatrix) & !inherits(topcut, "warning")) {
    imageWithoutTopBottom <- imageMatrix[-c(0:topcut, bottomcut:nrow(image)), ]
    vert <- t(imageWithoutTopBottom)
    rolledImage <- t(rollmean(vert, k = 75, fill = "extend"))
    rolledImage[which(rolledImage != 0)] <- 1
    
    topEnvelope <- .top_env(rolledImage, sepDist = 20, max_roc = 75)
    topEnvelopeScaled <- nrow(imageMatrix) - bottomcut + topEnvelope 
    bottomEnvelope <- .bottom_env(rolledImage, sepDist = 20, max_roc = 75)
    bottomEnvelopeScaled <- nrow(imageMatrix) - bottomcut + bottomEnvelope
    topLowerEnv <- .top_lower_env(rolledImage, sepDist = 20, max_roc = 75)
    topLowerEnvScaled <- nrow(imageMatrix) - bottomcut + topLowerEnv
    bottomUpperEnv <- .bottom_upper_env(rolledImage, sepDist = 20, max_roc = 75)
    bottomUpperEnvScaled <- nrow(imageMatrix) - bottomcut + bottomUpperEnv
    suppressWarnings(plot(imageMatrix))#processed image
    lines(topEnvelopeScaled, col = "green")
    lines(bottomEnvelopeScaled, col = "yellow")
    lines(topLowerEnvScaled, col = "green")
    lines(bottomUpperEnvScaled, col = "yellow")
    abline(h = (nrow(imageMatrix) - topcut), col = "red") 
    abline(h = (nrow(imageMatrix) - bottomcut), col = "red")
    
    for (m in imageSides$Start:imageSides$End) {
      if (topLowerEnv[m] == bottomUpperEnv[m]) {
        warning(paste0("There is an intersection at (", topLowerEnv[m], ", ", m, ")"))
        print(imageName)
        break
      }
    }
  }
# suppressWarnings(plot(imageMatrix))
#   abline(h = (nrow(imageMatrix) - topcut), col = "green")
#   abline(h = (nrow(imageMatrix) - bottomcut), col = "green")
#   abline(v = c(imageSides$Start, imageSides$End), col = "green")
#   text(imageSides$Start, x = 800, y = 1500, col = "green")
#   text(imageSides$End, x = 5000, y = 1500, col = "green")
```
```{r}
.top_lower_env <- function(rolledImage, max_roc = 25, sepDist = 10){
  max_white <- apply(rolledImage, MARGIN = 2, FUN = function(x) {
    if (sum(x) == 0) {
      chosenBottom <- 0
    }
    else {
      minWhite <- min( which(x == 1) )
      black <- which(x == 0)
      chosenBottom <- min(black[which(black > minWhite)])
    }
    return(chosenBottom)
  })

 #starting at the middle to be safe, will work backwards after
  foundNonZero <- FALSE
  for (i in (round(ncol(rolledImage))/2):ncol(rolledImage)) { # need for loop because need to be able to just back an index
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( i == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i - 1]
      diff <- x - oneLess
      if (abs(diff) >= max_roc) { # big change, could be a jump
          max_white[i] <- max_white[i - 1]
        
      }
    }
  }

  # The reverse, the first half of the image
  foundNonZero <- FALSE
  for (j in 1:(round(ncol(rolledImage))/2 )) { # need for loop because need to be able to just back an index
    i <- (round(ncol(rolledImage))/2 + 1) - j
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( j == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i + 1] # actually more because reverse indexing
      diff <-  oneLess - x # remember that the picture is reversed aswell, 0 is the top..
      if (abs(diff) >= max_roc) { # big change, could be a jump
          max_white[i] <- max_white[i + 1]
      }
    }
  }
  correctedWhite <- nrow(rolledImage) - max_white - sepDist # because image is actually flipped with respect to the matrix
  return(correctedWhite)
}

```


```{r Trash}
#.bottom_env <- function(rolledImage, max_roc = 10, sepDist = 10){
max_roc = 10
sepDist = 10
  max_white <- apply(rolledImage, MARGIN = 2, FUN = function(x) {
    if (sum(x) == 0) {
      white <- 0
    }
    else {
      white <- max( which(x == 1) )
    }
    return(white)
  })

  #starting at the middle to be safe, will work backwards after
  foundNonZero <- FALSE
  for (i in (round(ncol(rolledImage))/2):ncol(rolledImage)) { # need for loop because need to be able to just back an index
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( i == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i - 1]
      diff <- x - oneLess
      if (diff >= max_roc) { # big change, could be a jump
        if (diff > 0) { # new point is higher then old point
          max_white[i] <- max_white[i - 1] + 2 # 2 added to be safe
        }
        if (diff < 0) { # new point is below old point, cold be a timing gap
          max_white[i] <- max_white[i - 1] - 2 # 2 subtracted to be safe
        }
      }
    }
  }

  # The reverse, the first half of the image
  foundNonZero <- FALSE
  for (j in 1:(round(ncol(rolledImage))/2 )) { # need for loop because need to be able to just back an index
    i <- (round(ncol(rolledImage))/2 + 1) - j
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( j == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i + 1] # actually more because reverse indexing
      diff <-  oneLess - x # remember that the picture is reversed aswell, 0 is the top..
      if (diff >= max_roc) { # big change, could be a jump
        #browser()
        if (diff > 0) { # new point is higher then old point (looking at the image)
          max_white[i] <- max_white[i + 1]
        }
        if (diff < 0) { # new point is below old point, cold be a timing gap (lookug at the image)
          max_white[i] <- max_white[i + 1]
        }
      }
    }
  }
  correctedWhite <- nrow(rolledImage) - max_white + sepDist # because image is actually flipped with respect to the matrix
 # return(correctedWhite)
#}

plot(rolledImage)
lines(y = correctedWhite, x = 1:ncol(imageWithoutTopBottom), col = "green")

```



```{r}
.envelope_creation <- function(rolledImage, chosenRoughBound, max_roc = 25, topOfLine = TRUE){
  foundNonZero <- FALSE
  #second half of image
  for (i in (round(ncol(rolledImage))/2):ncol(rolledImage)) {
    x <- chosenRoughBound[i]
    #first column or no nonZero column found yet
    if ( i == 1 || isFALSE(foundNonZero)) {
      if (chosenRoughBound[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- chosenRoughBound[i - 1]
      diff <- x - oneLess
      if (abs(diff) >= max_roc) { # big change, could be a jump
        chosenRoughBound[i] <- chosenRoughBound[i - 1]
      }
    }
  }
  foundNonZero <- FALSE
  #first half of image
  for (j in 1:(round(ncol(rolledImage))/2 )) { 
    i <- (round(ncol(rolledImage))/2 + 1) - j
    x <- chosenRoughBound[i]
    #first column or no nonZero column found yet
    if ( j == 1 || isFALSE(foundNonZero)) {
      if (chosenRoughBound[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- chosenRoughBound[i + 1] # actually more because reverse indexing
      diff <-  oneLess - x # remember that the picture is reversed as well, 0 is the top..
      if (abs(diff) >= max_roc) { # big change, could be a jump
          chosenRoughBound[i] <- chosenRoughBound[i + 1]
      }
    }
  }
  if (isTRUE(topOfLine)) {
    correctedWhite <- nrow(rolledImage) - max_white + sepDist
  }
  else{ #running on the bottom of the image
    correctedWhite <- nrow(rolledImage) - max_white - sepDist
  }
  return(correctedWhite)
}
```




```{r}
k <- k + 1
```


```{r}
#these are both random samples, of the successes of the start and ends
start <- c(346, 371, 80, 208, 268, 222, 274, 95, 330, 427, 271, 262, 390, 352,
           354, 436, 175, 377, 225, 315, 352, 351, 264, 339, 149, 318, 327, 499,
           401, 401, 346, 358, 329, 249, 320, 360, 255, 276, 324, 242, 288, 197, 
           289, 399, 282, 314, 326, 314, 355, 341, 293, 352, 337, 374, 354, 414,
           354, 636, 183, 357, 305, 327, 336, 359, 349, 292, 282, 287, 256, 301, 
           162)

end <- c(5940, 5883, 5712, 6042, 6033, 6035, 6030, 5788, 5952, 5966, 5904, 5914,
         5967, 6028, 5903, 5991, 5808, 6046, 5885, 5967, 5959, 5953, 5881, 5943,
         6058, 5937, 5920, 5983, 5920, 5903, 5929, 5967, 5894, 6008, 6112, 5821,
         5046, 5909, 5916, 5867, 5882, 5865, 5845, 5925, 5901, 5909, 5901, 6059,
         5958, 6036, 5791, 5908, 5895, 5948, 5790, 5486, 5658, 6002, 5702, 5927, 
         6064, 5930, 5904, 5942, 5892, 5908, 5833, 5882, 5819, 5897, 5849)

startEnd <- data.frame(start = start, end = end)
```



```{r 200813 testing out timing bounds}
library("magneto")
library("zoo")
library("rtiff")
ImageTesting <- read.csv("~/Magneto2020/DataCSV/TODOBatch5.csv", header = TRUE, stringsAsFactors = FALSE)
k <- 1
j <- sample(1:26000, size = 100, replace = FALSE)
flag = FALSE

for (k in 1:2) {

  i <- j[k]
  print(i)
  a <- Sys.time()
  file_loc <- as.character(ImageTesting[i,1])
  imageName <- as.character(ImageTesting[i,2])
  print(imageName)
  imageMatrix <- import_process_image(imageName = imageName, file_loc = file_loc)
  imagecut <- .trim_top_bottom(imageMatrix, trimAmountTop = 100, trimAmountBottom = 50) #takes off the usual flair spots
  imageSides <- .get_trace_start_ends(imagecut, returnMat = FALSE, cutPercentage = 2) # two vertical lines (est for the bounds)
  tripleBool <- .triple_check(imageMatrix = imageMatrix)
  if (isTRUE(tripleBool)) {
    print("possible triple found!")
    next
  }
  #This is where we should do the sep of the timing marks

  #imageMatrix <- edge_detection(imagecut, method = "Sobel")
  imageWithoutSides <- imageMatrix[, -c(0:imageSides$Start, imageSides$End:ncol(imageMatrix))] #takes away the sides found above
  # finds top horizontal line
  topcut <- .top_image_cut(imageMatrix = imageWithoutSides, percentFromEdge = 2, percentEdgeForLeft = 25)
  #finds bottom horizontal line
  bottomcut <- tryCatch(magneto::.bottom_image_cut(imageMatrix = imageWithoutSides, percentEdgeForLeft = 25,
                                                   percentFromEdge = 2, shortestAlowedSeqOfZeros = 25), warning = function(w) w)
  #could be that no cut was found, both of those functions throw an error when this happens
  if (inherits(topcut, "warning") || inherits(bottomcut, "warning")) {
    print(bottomcut)
    print(imageName)
    flag = TRUE
    bottomcut <- nrow(imageMatrix) # this is the only way I know of doing this
  }
  #No warnings, then we can roll mean the image and work on the bounds
  else {#if (bottomcut != nrow(imageMatrix) & !inherits(topcut, "warning")) {
    imageTimings <- imageMatrix[-c(0:bottomcut),]
    Timings <- find_peaks(rowSums(imageTimings), minDistance = 50, maxPeakNumber = 2, percentFromEdge = 2, plots = FALSE)
    
    
    
    
    imageWithoutTopBottom <- imageMatrix[-c(0:topcut, bottomcut:nrow(image)), ]
    vert <- t(imageWithoutTopBottom)
    rolledImage <- t(rollmean(vert, k = 40, fill = "extend"))
    rolledImage[which(rolledImage != 0)] <- 1

    #the envelopes
    topEnvelope <- .top_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    topEnvelopeScaled <- nrow(imageMatrix) - bottomcut + topEnvelope
    bottomEnvelope <- .bottom_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    bottomEnvelopeScaled <- nrow(imageMatrix) - bottomcut + bottomEnvelope
    topLowerEnv <- .top_lower_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    topLowerEnvScaled <- nrow(imageMatrix) - bottomcut + topLowerEnv
    bottomUpperEnv <- .bottom_upper_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    bottomUpperEnvScaled <- nrow(imageMatrix) - bottomcut + bottomUpperEnv


     # Open a png file
    png(paste0("~/Magneto2020/plottingTesting/", imageName, ".png"))
    # 2. Create a plot
    suppressWarnings(plot(imageMatrix))
    lines(topEnvelopeScaled, col = "green")
    lines(bottomEnvelopeScaled, col = "yellow")
    lines(topLowerEnvScaled, col = "green")
    lines(bottomUpperEnvScaled, col = "yellow")
    abline(h = (nrow(imageMatrix) - topcut), col = "red")
    abline(h = (nrow(imageMatrix) - bottomcut), col = "red")
    # Close the pdf file
    dev.off()

    # if (imageSides$End >=  length(topLowerEnv)) {
    #   end <- length(topLowerEnv - 200) # 200 to keep away from the sides
    # }
    # else {
    #   end <- imageSides$End
    # }
    for (m in 300:(min(c(length(bottomUpperEnv), length(topLowerEnv))) - 300)) { #Checking for intersection between the two lines
      if (topLowerEnv[m] <= bottomUpperEnv[m]) {
        print(warning(paste0("There is an intersection at (", topLowerEnv[m], ", ", m, ")")))
        print(imageName)
        break
      }
    }
  }
  if (isTRUE(flag)) { # plotting so I can see whats wrong
    flag = FALSE
    # Open a pdf file
    png(paste0("~/Magneto2020/plottingTesting/", imageName, "failProcess", ".png"))
    # 2. Create a plot
    suppressWarnings(plot(imageMatrix))
    abline(h = (nrow(imageMatrix) - topcut), col = "green")
    abline(h = (nrow(imageMatrix) - bottomcut), col = "green")
    abline(v = c(imageSides$Start, imageSides$End), col = "green")
    text(imageSides$Start, x = 800, y = 1500, col = "green")
    text(imageSides$End, x = 5000, y = 1500, col = "green")
    text("This Isn't Processed", x = 3000, y = 1500, col = "orange")
    # Close the pdf file
    dev.off()
  }



  b <- Sys.time()
  print( b - a)
  print(" ")
  # # Open a pdf file
  # png(paste0("~/Magneto2020/plottingTesting/", imageName, ".png"))
  # # 2. Create a plot
  # suppressWarnings(plot(imageMatrix))
  # abline(h = (nrow(imageMatrix) - topcut), col = "green")
  # abline(h = (nrow(imageMatrix) - bottomcut), col = "green")
  # abline(v = c(imageSides$Start, imageSides$End), col = "green")
  # text(imageSides$Start, x = 800, y = 1500, col = "green")
  # text(imageSides$End, x = 5000, y = 1500, col = "green")
  # # Close the pdf file
  # dev.off()
}
```



```{r}
#getting just the top trace (assuming no intersection)
topTraceMatrix <- imageMatrix

for (j in 1:ncol(topTraceMatrix)) {
  for (i in 1:nrow(topTraceMatrix)) {
    if (topTraceMatrix[i,j] > topEnvelopeScaled[i]) {
      topTraceMatrix[i,j] <- 0
      next
    }
    if (topTraceMatrix[i,j] < topLowerEnvScaled[i]) {
      topTraceMatrix[i,j] <- 0
      next
    }
  }
}
```
```{r}
topTraceMatrix <- apply(imageMatrix, MARGIN = 2, FUN = function(x){
  for (i in 1:length(x)) {
    if (x[i] > topEnvelopeScaled[i]) {
      x[i] <- 0
      #next
    }
    if (x[i] < topLowerEnvScaled[i]) {
      x[i] <- 0
      #next
    }
  }
})
```


Need to double for loop to make all other parts black, then we can draw a line between the two lines, up or down resp
with this we should have two seperated traces that will be easy to get the final bounds, because there will be a clear
part where the trace gaps to be the number at the end of the trace!



```{r}
TIS <- function(imageName, fileLoc, pathToWorkingDir = "~/", TODOCSV,
                HDVcheck = FALSE, plotPNG = TRUE,
                trimAmountTop = 100,
                trimAmountBottom = 50, beta0 = -2.774327,
                beta1 = 51.91687, cutoffProbability = 0.5,
                NADefault = 0, FilterBright = c(13, 13),
                FilterNonBright = c(8, 8),
                methodBright = "delation",
                methodNonBright = "delation",
                thresholdBright = 0.8,
                thresholdNonBright = 0.5, trimAmountLeft = 2, trimAmountRight = 2,
                percentFromEdge = 2, percentEdgeForLeft = 25,
                cutPercentage = 2, shortestAllowedSeqOfZeros = 25,
                minDistance = 50, thresholdHeight = 200,
                thresholdDistance = 250, threshCutImage = 500,
                sepDist = 10, max_roc = 35, maxNoise = 250,
                envelopeStartEndThreshold = 300, intersetionRemoveAmount = 1000,
                CreateTraceThreshold = 5, MARange = 6, region = 2,
                loopNumber = 4, spikeThreshold = 50, rollFill = "extend", k = 40){
  traceWarnings <- vector()
  typeCheck <- NULL # if you aren't using the HDV check
  
  if (isTRUE(HDVcheck)) {
  # HDV Checking for Magnetograms ----------------------------------------------
    typeCheck <- tryCatch(.hdv_check(imageName), warning = function(w) w)
  }
  if (inherits(typeCheck, "warning")) {
    print(typeCheck)
    traceWarnings <- append(traceWarnings, vector)
    flag = TRUE #wont process, but will put a plot out into the pwd
  }
  else {
  # Process The Image ----------------------------------------------------------
    
    imageMatrix <- import_process_image(imageName = imageName, file_loc = fileLoc,
                                        trimAmountTop = trimAmountTop,
                                        trimAmountBottom = trimAmountBottom, beta0 = beta0,
                                        beta1 = beta1, cutoffProbability = cutoffProbability,
                                        NADefault = NADefault, FilterBright = FilterBright,
                                        FilterNonBright = FilterNonBright,
                                        methodBright = methodBright,
                                        methodNonBright = methodNonBright,
                                        thresholdBright = thresholdBright,
                                        thresholdNonBright = thresholdNonBright)
    imageSideCut <- .trim_Sides(imageMatrix, trimAmountLeft = trimAmountLeft, 
                                trimAmountRight = trimAmountRight) 
    imageCut <- .trim_top_bottom(imageSideCut, trimAmountTop = trimAmountTop, 
                                 trimAmountBottom = trimAmountBottom) 
    #takes off the usual flair spots
  
  # Find the Top and Bottom Cut for the Image ----------------------------------- 
    
    topBottomCuts <- find_cuts(imageCut, percentFromEdge = percentFromEdge, 
                               percentEdgeForLeft = percentEdgeForLeft, 
                               cutPercentage = cutPercentage, 
                               shortestAllowedSeqOfZeros = shortestAllowedSeqOfZeros)
    topCut <- topBottomCuts$TopCut
    bottomCut <- topBottomCuts$BottomCut
    if (inherits(topCut, "warning")) {
      print(topBottomCuts$TopCut)
      traceWarnings <- append(traceWarnings, topCut)
      flag = TRUE #wont process, but will put a plot out into the pwd
      topCut <- 0
    }
    if (inherits(bottomCut, "warning")) {
      print(topBottomCuts$BottomCut)
      traceWarnings <- append(traceWarnings, bottomCut)
      flag = TRUE #wont process, but will put a plot out into the pwd
      bottomCut <- nrow(imageCut)
    }
  }
  
  if (isFALSE(flag)) {
  # Check for a Triple Set of Traces -------------------------------------------
    tripleBool <- .triple_check(imageMatrix = imageCut, topCut = topcut, 
                                bottomCut = bottomcut, minDistance = minDistance,
                                percentFromEdge = percentFromEdge, thresholdHeight = thresholdHeight,
                                thresholdDistance = thresholdDistance, threshCutImage = threshCutImage) #checking for triple trace images
    if (isTRUE(tripleBool)) {
      print(paste0("possible triple found! ", imageName))
    }
  # No Errors Found, Creating The Actual Traces --------------------------------
    else {
  
  # Creating Envelopes ---------------------------------------------------------
      rolledImage <- mean_roll_image(imageMatrix = imageCut, topcut = topCut,
                                     bottomcut =  bottomCut, fill = rollFill, k = k) #to get a more consistent image
      #gets rid of small gaps
      matrixEnvelopes <- find_envelopes(imageMatrix = imageCut, rolledImage = rolledImage, bottomCut = bottomCut,
                                        returnType = "MatrixScaled", sepDist = sepDist,
                                        max_roc = max_roc, maxNoise = maxNoise)
      
      traceMatrices <- isolate_traces(imageCut, topEnvelope = matrixEnvelopes$TopEnvelope,
                     topLowerEnvelope = matrixEnvelopes$TopLowerEnvelope,
                     bottomUpperEnvelope = matrixEnvelopes$BottomUpperEnvelope,
                     bottomEnvelope = matrixEnvelopes$BottomEnvelope)
      
      TopStartsEnds <- .env_start_end(traceMatrix = traceMatrices$TopTraceMatrix, 
                                        returnMatrix = FALSE, thresh = envelopeStartEndThreshold)
      BottomStartsEnds <- .env_start_end(traceMatrix = traceMatrices$BottomTraceMatrix,
                                           returnMatrix = FALSE, thresh = envelopeStartEndThreshold)
      
  # Checking Envelopes for Intersections ---------------------------------------    
      
      intersection <- tryCatch(.intersection_check(topEnv = matrixEnvelopes$TopLowerEnvelope,
                                                 bottomEnv = matrixEnvelopes$BottomUpperEnv,
                                                 imageName, rmAmount = intersetionRemoveAmount),
                                                 warning = function(w) w)
      if (inherits(intersection, "warning")) {
        print(intersection)
        traceWarnings <- append(traceWarnings, intersection)
      }
      
  # Creating the Two Traces ----------------------------------------------------   
      
      topTrace <- create_trace(traceMatrix = traceMatrices$TopTraceMatrix, 
                               start = TopStartsEnds$Start,
                               end = TopStartsEnds$End,
                               topEnv = matrixEnvelopes$TopEnvelope,
                               bottomEnv =  matrixEnvelopes$TopLowerEnvelope,
                               thresh = CreateTraceThreshold,
                               MARange = MARange, region = region, loopNumber = loopNumber)
      bottomTrace <- create_trace(traceMatrix = traceMatrices$BottomTraceMatrix,
                                  start =  BottomStartsEnds$Start,
                                  end =  BottomStartsEnds$End,
                                  topEnv = matrixEnvelopes$BottomUpperEnvelope,
                                  bottomEnv = matrixEnvelopes$BottomEnvelope,
                                  thresh = CreateTraceThreshold,
                                  MARange = MARange, region = region, 
                                  loopNumber = loopNumber)
      
  # Checking for spikes in the traces ------------------------------------------
      topTraceSpikeCheck <- tryCatch(.spike_check(topTrace, spikeThreshold = spikeThreshold))
      bottomTraceSpikeCheck <- tryCatch(.spike_check(bottomTrace, spikeThreshold = spikeThreshold))
      if (inherits(topTraceSpikeCheck, "warning") || inherits(bottomTraceSpikeCheck, "warning")) {
        if (!is.null(topTraceSpikeCheck)) {
          print(topTraceSpikeCheck)
          traceWarnings <- append(traceWarnings, topTraceSpikeCheck)
        }
        if (!is.null(bottomTraceSpikeCheck)) {
          print(bottomTraceSpikeCheck)
          traceWarnings <- append(traceWarnings, bottomTraceSpikeCheck)
        }
      }
      
    }
    
  }
  # Plotting (if applicable) ---------------------------------------------------
  if (isTRUE(plotPNG) & isFALSE(flag)) {
    plot_success(imageMatrix = imageCut, rolledImage = rolledImage, topCut = topCut,
                bottomCut = bottomCut, topStartEnds = TopStartsEnds, bottomStartEnds = BottomStartsEnds,
                topTrace = topTrace, bottomTrace = bottomTrace, maxNoise = maxNoise, max_roc = max_roc,
                sepDist = sepDist, pathToWorkingDir = pathToWorkingDir, imageName = imageName)
    
    
  }
  if (isTRUE(plotPNG)) {
    plot_with_warnings(imageMatrix = imageCut, topCut = topCut, bottomCut = bottomCut
                       ,pathToWorkingDir = pathToWorkingDir, imageName = imageName)
  }
  totalReturn <- list(ImageCutMatrix = imageCut, RolledImage = rolledImage, TopTraceMatrix = topTrace,
                      TopTraceStartEnds = list(Start = TopStartsEnds$Start, End = TopStartsEnds$End),
                      BottomTraceMatrix = bottomTrace,
                      BottomTraceStartEnds = list(Start = BottomStartsEnds$Start, End = BottomStartsEnds$End),
                      Cuts = list(TopCut = topCut, BottomCut = bottomCut),
                      Warnings = traceWarnings)
  return(totalReturn)
}
```

```{r}

```

```{r}
plot_with_warnings <- function(imageMatrix, topCut, bottomCut, pathToWorkingDir = "~/"){
  
  png(paste0(pathToWorkingDir, imageName, "failProcess", ".png"))
    # 2. Create a plot
    suppressWarnings(plot(imageMatrix))
    abline(h = (nrow(imageMatrix) - topCut), col = "green")
    abline(h = (nrow(imageMatrix) - bottomCut), col = "green")
    text("This Isn't Processed", x = 3000, y = 1500, col = "orange")
    # Close the png file
    dev.off()
}
```

