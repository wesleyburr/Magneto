---
title: "testingEnv"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
ImageTesting <- read.csv("~/Magneto2020/DataCSV/TODOBatch5.csv", header = TRUE, stringsAsFactors = FALSE)
```
```{r}
k <- 4
j <- sample(1:26000, size = 100, replace = FALSE)

```


```{r}
#for k in 1:100)
i <- j[k]
#i <- 1
#library(magneto)
#library("zoo")
  file_loc <- as.character(ImageTesting[i,1])
  imageName <- as.character(ImageTesting[i,2])

  imageRAW <- tiff_import(fileName = imageName, fileLoc = file_loc)
  image <- magneto::.horizontal_image_check(imageRAW)
  imagecut <- magneto::.trim_top_bottom(image, trimAmountTop = 100, trimAmountBottom = 50) #takes off the usual flair spots
  #imageSides <- magneto::.get_trace_start_ends(imagecut, returnMat = FALSE)
  imageSides <- magneto::.get_trace_start_ends(imagecut, returnMat = FALSE, cutPercentage = 2) # two vertical lines
  imageMatrix <- .process_image(imagecut) # checks bright and processes returns processed
  #imageMatrix <- edge_detection(imagecut, method = "Sobel")
  imageWithoutSides <- imageMatrix[, -c(0:imageSides$Start, imageSides$End:ncol(imageMatrix))] #takes away the sides found above
  # finds top horizontal line
  topcut <- magneto::.top_image_cut(imageMatrix = imageWithoutSides, percentFromEdge = 2, percentEdgeForLeft = 25)
  #finds bottom horizontal line
  bottomcut <- tryCatch(magneto::.bottom_image_cut(imageMatrix = imageWithoutSides, percentEdgeForLeft = 25,
                                                   percentFromEdge = 2, shortestAlowedSeqOfZeros = 15), warning = function(w) w)
  if (inherits(bottomcut, "warning")) {
    print(bottomcut)
    print(imageName)
    bottomcut <- nrow(imageMatrix) # this is the only way I know of doing this
  }
  if (bottomcut != nrow(imageMatrix) & !inherits(topcut, "warning")) {
    imageWithoutTopBottom <- imageMatrix[-c(0:topcut, bottomcut:nrow(image)), ]
    vert <- t(imageWithoutTopBottom)
    rolledImage <- t(rollmean(vert, k = 75, fill = "extend"))
    rolledImage[which(rolledImage != 0)] <- 1
    
    topEnvelope <- .top_env(rolledImage, sepDist = 20, max_roc = 75)
    topEnvelopeScaled <- nrow(imageMatrix) - bottomcut + topEnvelope 
    bottomEnvelope <- .bottom_env(rolledImage, sepDist = 20, max_roc = 75)
    bottomEnvelopeScaled <- nrow(imageMatrix) - bottomcut + bottomEnvelope
    topLowerEnv <- .top_lower_env(rolledImage, sepDist = 20, max_roc = 75)
    topLowerEnvScaled <- nrow(imageMatrix) - bottomcut + topLowerEnv
    bottomUpperEnv <- .bottom_upper_env(rolledImage, sepDist = 20, max_roc = 75)
    bottomUpperEnvScaled <- nrow(imageMatrix) - bottomcut + bottomUpperEnv
    suppressWarnings(plot(imageMatrix))#processed image
    lines(topEnvelopeScaled, col = "green")
    lines(bottomEnvelopeScaled, col = "yellow")
    lines(topLowerEnvScaled, col = "green")
    lines(bottomUpperEnvScaled, col = "yellow")
    abline(h = (nrow(imageMatrix) - topcut), col = "red") 
    abline(h = (nrow(imageMatrix) - bottomcut), col = "red")
    
    for (m in imageSides$Start:imageSides$End) {
      if (topLowerEnv[m] == bottomUpperEnv[m]) {
        warning(paste0("There is an intersection at (", topLowerEnv[m], ", ", m, ")"))
        print(imageName)
        break
      }
    }
  }
# suppressWarnings(plot(imageMatrix))
#   abline(h = (nrow(imageMatrix) - topcut), col = "green")
#   abline(h = (nrow(imageMatrix) - bottomcut), col = "green")
#   abline(v = c(imageSides$Start, imageSides$End), col = "green")
#   text(imageSides$Start, x = 800, y = 1500, col = "green")
#   text(imageSides$End, x = 5000, y = 1500, col = "green")
```
```{r}
.top_lower_env <- function(rolledImage, max_roc = 25, sepDist = 10){
  max_white <- apply(rolledImage, MARGIN = 2, FUN = function(x) {
    if (sum(x) == 0) {
      chosenBottom <- 0
    }
    else {
      minWhite <- min( which(x == 1) )
      black <- which(x == 0)
      chosenBottom <- min(black[which(black > minWhite)])
    }
    return(chosenBottom)
  })

 #starting at the middle to be safe, will work backwards after
  foundNonZero <- FALSE
  for (i in (round(ncol(rolledImage))/2):ncol(rolledImage)) { # need for loop because need to be able to just back an index
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( i == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i - 1]
      diff <- x - oneLess
      if (abs(diff) >= max_roc) { # big change, could be a jump
          max_white[i] <- max_white[i - 1]
        
      }
    }
  }

  # The reverse, the first half of the image
  foundNonZero <- FALSE
  for (j in 1:(round(ncol(rolledImage))/2 )) { # need for loop because need to be able to just back an index
    i <- (round(ncol(rolledImage))/2 + 1) - j
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( j == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i + 1] # actually more because reverse indexing
      diff <-  oneLess - x # remember that the picture is reversed aswell, 0 is the top..
      if (abs(diff) >= max_roc) { # big change, could be a jump
          max_white[i] <- max_white[i + 1]
      }
    }
  }
  correctedWhite <- nrow(rolledImage) - max_white - sepDist # because image is actually flipped with respect to the matrix
  return(correctedWhite)
}

```


```{r Trash}
#.bottom_env <- function(rolledImage, max_roc = 10, sepDist = 10){
max_roc = 10
sepDist = 10
  max_white <- apply(rolledImage, MARGIN = 2, FUN = function(x) {
    if (sum(x) == 0) {
      white <- 0
    }
    else {
      white <- max( which(x == 1) )
    }
    return(white)
  })

  #starting at the middle to be safe, will work backwards after
  foundNonZero <- FALSE
  for (i in (round(ncol(rolledImage))/2):ncol(rolledImage)) { # need for loop because need to be able to just back an index
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( i == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i - 1]
      diff <- x - oneLess
      if (diff >= max_roc) { # big change, could be a jump
        if (diff > 0) { # new point is higher then old point
          max_white[i] <- max_white[i - 1] + 2 # 2 added to be safe
        }
        if (diff < 0) { # new point is below old point, cold be a timing gap
          max_white[i] <- max_white[i - 1] - 2 # 2 subtracted to be safe
        }
      }
    }
  }

  # The reverse, the first half of the image
  foundNonZero <- FALSE
  for (j in 1:(round(ncol(rolledImage))/2 )) { # need for loop because need to be able to just back an index
    i <- (round(ncol(rolledImage))/2 + 1) - j
    x <- max_white[i]
    #first column or no nonZero column found yet
    if ( j == 1 || isFALSE(foundNonZero)) {
      if (max_white[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- max_white[i + 1] # actually more because reverse indexing
      diff <-  oneLess - x # remember that the picture is reversed aswell, 0 is the top..
      if (diff >= max_roc) { # big change, could be a jump
        #browser()
        if (diff > 0) { # new point is higher then old point (looking at the image)
          max_white[i] <- max_white[i + 1]
        }
        if (diff < 0) { # new point is below old point, cold be a timing gap (lookug at the image)
          max_white[i] <- max_white[i + 1]
        }
      }
    }
  }
  correctedWhite <- nrow(rolledImage) - max_white + sepDist # because image is actually flipped with respect to the matrix
 # return(correctedWhite)
#}

plot(rolledImage)
lines(y = correctedWhite, x = 1:ncol(imageWithoutTopBottom), col = "green")

```



```{r}
.envelope_creation <- function(rolledImage, chosenRoughBound, max_roc = 25, topOfLine = TRUE){
  foundNonZero <- FALSE
  #second half of image
  for (i in (round(ncol(rolledImage))/2):ncol(rolledImage)) {
    x <- chosenRoughBound[i]
    #first column or no nonZero column found yet
    if ( i == 1 || isFALSE(foundNonZero)) {
      if (chosenRoughBound[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- chosenRoughBound[i - 1]
      diff <- x - oneLess
      if (abs(diff) >= max_roc) { # big change, could be a jump
        chosenRoughBound[i] <- chosenRoughBound[i - 1]
      }
    }
  }
  foundNonZero <- FALSE
  #first half of image
  for (j in 1:(round(ncol(rolledImage))/2 )) { 
    i <- (round(ncol(rolledImage))/2 + 1) - j
    x <- chosenRoughBound[i]
    #first column or no nonZero column found yet
    if ( j == 1 || isFALSE(foundNonZero)) {
      if (chosenRoughBound[i] != 0) {
        foundNonZero <- TRUE
      }
    }
    # a non zero column is found
    else if (isTRUE(foundNonZero)) {
      oneLess <- chosenRoughBound[i + 1] # actually more because reverse indexing
      diff <-  oneLess - x # remember that the picture is reversed as well, 0 is the top..
      if (abs(diff) >= max_roc) { # big change, could be a jump
          chosenRoughBound[i] <- chosenRoughBound[i + 1]
      }
    }
  }
  if (isTRUE(topOfLine)) {
    correctedWhite <- nrow(rolledImage) - max_white + sepDist
  }
  else{ #running on the bottom of the image
    correctedWhite <- nrow(rolledImage) - max_white - sepDist
  }
  return(correctedWhite)
}
```




```{r}
k <- k + 1
```


```{r}
#these are both random samples, of the successes of the start and ends
start <- c(346, 371, 80, 208, 268, 222, 274, 95, 330, 427, 271, 262, 390, 352,
           354, 436, 175, 377, 225, 315, 352, 351, 264, 339, 149, 318, 327, 499,
           401, 401, 346, 358, 329, 249, 320, 360, 255, 276, 324, 242, 288, 197, 
           289, 399, 282, 314, 326, 314, 355, 341, 293, 352, 337, 374, 354, 414,
           354, 636, 183, 357, 305, 327, 336, 359, 349, 292, 282, 287, 256, 301, 
           162)

end <- c(5940, 5883, 5712, 6042, 6033, 6035, 6030, 5788, 5952, 5966, 5904, 5914,
         5967, 6028, 5903, 5991, 5808, 6046, 5885, 5967, 5959, 5953, 5881, 5943,
         6058, 5937, 5920, 5983, 5920, 5903, 5929, 5967, 5894, 6008, 6112, 5821,
         5046, 5909, 5916, 5867, 5882, 5865, 5845, 5925, 5901, 5909, 5901, 6059,
         5958, 6036, 5791, 5908, 5895, 5948, 5790, 5486, 5658, 6002, 5702, 5927, 
         6064, 5930, 5904, 5942, 5892, 5908, 5833, 5882, 5819, 5897, 5849)

startEnd <- data.frame(start = start, end = end)
```



```{r 200813 testing out timing bounds}
library("magneto")
library("zoo")
library("rtiff")
ImageTesting <- read.csv("~/Magneto2020/DataCSV/TODOBatch5.csv", header = TRUE, stringsAsFactors = FALSE)
k <- 1
j <- sample(1:26000, size = 100, replace = FALSE)
flag = FALSE

for (k in 1:2) {

  i <- j[k]
  print(i)
  a <- Sys.time()
  file_loc <- as.character(ImageTesting[i,1])
  imageName <- as.character(ImageTesting[i,2])
  print(imageName)
  imageMatrix <- import_process_image(imageName = imageName, file_loc = file_loc)
  imagecut <- .trim_top_bottom(imageMatrix, trimAmountTop = 100, trimAmountBottom = 50) #takes off the usual flair spots
  imageSides <- .get_trace_start_ends(imagecut, returnMat = FALSE, cutPercentage = 2) # two vertical lines (est for the bounds)
  tripleBool <- .triple_check(imageMatrix = imageMatrix)
  if (isTRUE(tripleBool)) {
    print("possible triple found!")
    next
  }
  #This is where we should do the sep of the timing marks

  #imageMatrix <- edge_detection(imagecut, method = "Sobel")
  imageWithoutSides <- imageMatrix[, -c(0:imageSides$Start, imageSides$End:ncol(imageMatrix))] #takes away the sides found above
  # finds top horizontal line
  topcut <- .top_image_cut(imageMatrix = imageWithoutSides, percentFromEdge = 2, percentEdgeForLeft = 25)
  #finds bottom horizontal line
  bottomcut <- tryCatch(magneto::.bottom_image_cut(imageMatrix = imageWithoutSides, percentEdgeForLeft = 25,
                                                   percentFromEdge = 2, shortestAlowedSeqOfZeros = 25), warning = function(w) w)
  #could be that no cut was found, both of those functions throw an error when this happens
  if (inherits(topcut, "warning") || inherits(bottomcut, "warning")) {
    print(bottomcut)
    print(imageName)
    flag = TRUE
    bottomcut <- nrow(imageMatrix) # this is the only way I know of doing this
  }
  #No warnings, then we can roll mean the image and work on the bounds
  else {#if (bottomcut != nrow(imageMatrix) & !inherits(topcut, "warning")) {
    imageTimings <- imageMatrix[-c(0:bottomcut),]
    Timings <- find_peaks(rowSums(imageTimings), minDistance = 50, maxPeakNumber = 2, percentFromEdge = 2, plots = FALSE)
    
    
    
    
    imageWithoutTopBottom <- imageMatrix[-c(0:topcut, bottomcut:nrow(image)), ]
    vert <- t(imageWithoutTopBottom)
    rolledImage <- t(rollmean(vert, k = 40, fill = "extend"))
    rolledImage[which(rolledImage != 0)] <- 1

    #the envelopes
    topEnvelope <- .top_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    topEnvelopeScaled <- nrow(imageMatrix) - bottomcut + topEnvelope
    bottomEnvelope <- .bottom_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    bottomEnvelopeScaled <- nrow(imageMatrix) - bottomcut + bottomEnvelope
    topLowerEnv <- .top_lower_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    topLowerEnvScaled <- nrow(imageMatrix) - bottomcut + topLowerEnv
    bottomUpperEnv <- .bottom_upper_env(rolledImage, sepDist = 10, max_roc = 50, maxNoise = 100)
    bottomUpperEnvScaled <- nrow(imageMatrix) - bottomcut + bottomUpperEnv


     # Open a png file
    png(paste0("~/Magneto2020/plottingTesting/", imageName, ".png"))
    # 2. Create a plot
    suppressWarnings(plot(imageMatrix))
    lines(topEnvelopeScaled, col = "green")
    lines(bottomEnvelopeScaled, col = "yellow")
    lines(topLowerEnvScaled, col = "green")
    lines(bottomUpperEnvScaled, col = "yellow")
    abline(h = (nrow(imageMatrix) - topcut), col = "red")
    abline(h = (nrow(imageMatrix) - bottomcut), col = "red")
    # Close the pdf file
    dev.off()

    # if (imageSides$End >=  length(topLowerEnv)) {
    #   end <- length(topLowerEnv - 200) # 200 to keep away from the sides
    # }
    # else {
    #   end <- imageSides$End
    # }
    for (m in 300:(min(c(length(bottomUpperEnv), length(topLowerEnv))) - 300)) { #Checking for intersection between the two lines
      if (topLowerEnv[m] <= bottomUpperEnv[m]) {
        print(warning(paste0("There is an intersection at (", topLowerEnv[m], ", ", m, ")")))
        print(imageName)
        break
      }
    }
  }
  if (isTRUE(flag)) { # plotting so I can see whats wrong
    flag = FALSE
    # Open a pdf file
    png(paste0("~/Magneto2020/plottingTesting/", imageName, "failProcess", ".png"))
    # 2. Create a plot
    suppressWarnings(plot(imageMatrix))
    abline(h = (nrow(imageMatrix) - topcut), col = "green")
    abline(h = (nrow(imageMatrix) - bottomcut), col = "green")
    abline(v = c(imageSides$Start, imageSides$End), col = "green")
    text(imageSides$Start, x = 800, y = 1500, col = "green")
    text(imageSides$End, x = 5000, y = 1500, col = "green")
    text("This Isn't Processed", x = 3000, y = 1500, col = "orange")
    # Close the pdf file
    dev.off()
  }



  b <- Sys.time()
  print( b - a)
  print(" ")
  # # Open a pdf file
  # png(paste0("~/Magneto2020/plottingTesting/", imageName, ".png"))
  # # 2. Create a plot
  # suppressWarnings(plot(imageMatrix))
  # abline(h = (nrow(imageMatrix) - topcut), col = "green")
  # abline(h = (nrow(imageMatrix) - bottomcut), col = "green")
  # abline(v = c(imageSides$Start, imageSides$End), col = "green")
  # text(imageSides$Start, x = 800, y = 1500, col = "green")
  # text(imageSides$End, x = 5000, y = 1500, col = "green")
  # # Close the pdf file
  # dev.off()
}
```



```{r}
for (i in 1:ncol(imageMatrix)) {
  for (i in 1)
  if (imageMatrix[i] < topEnvelopeScaled[i]) # this iwsnt done
}
```

Need to duble for loop to make all other parts black, then we can draw a line between the two lines, up or down resp
with this we should have two seperated traces that will be easy to get the final bounds, because there will be a clear
part where the trace gaps to be the number at the end of the trace!
